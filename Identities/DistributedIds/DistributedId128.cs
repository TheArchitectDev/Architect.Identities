using System;

// ReSharper disable once CheckNamespace
namespace Architect.Identities
{
	/// <summary>
	/// <para>
	/// A drop-in <see cref="Guid"/> replacement that provides values that are unique with exceedingly high probability, in a distributed fashion.
	/// </para>
	/// <para>
	/// <strong>Application:</strong> Although for most applications the <see cref="DistributedId"/> is more suitable than the <see cref="DistributedId128"/>, not all code can tolerate the former's constraints.
	/// For example, class libraries can make no assumptions about their host applications with regards to acceptable rate limits and collision probabilities.
	/// The <see cref="DistributedId128"/> offers practically no collisions, practically no rate limit, and the format of a valid version-7 UUID.
	/// </para>
	/// <para>
	/// <strong>Similarities:</strong> Like .NET's built-in version-4 <see cref="Guid"/> values, created values are exceedingly hard to guess and exceedingly unlikely to collide.
	/// </para>
	/// <para>
	/// <strong>Benefits:</strong> The values have the added benefit of being incremental. The incremental property generally makes values much more efficient as database/storage keys than random <see cref="Guid"/> values.
	/// </para>
	/// <para>
	/// <strong>Exposure:</strong> Note that the values expose their creation timestamps to some degree. This may be sensitive data in certain contexts.
	/// </para>
	/// <para>
	/// <strong>Rate limit:</strong> The rate limit per machine is over 100K IDs generated per millisecond, or 1 million per second, with threads sleeping if necessary.
	/// </para>
	/// <para>
	/// <strong>Collisions:</strong>
	/// For OTP, 1 million servers each generating 1 ID at the same millisecond, repeatedly, expect less than 1 collision per 75 <em>quadrillion</em> (75,000,000,000,000,000) IDs.
	/// For batch processing, 100K servers each generating 100K IDs at the same millisecond, repeatedly, expect less than 1 collision per 5 <em>trillion</em> (5,000,000,000,000) IDs.
	/// </para>
	/// <para>
	/// <strong>Sorting:</strong> The sort order of the resulting <see cref="Guid"/> values should only be relied upon within .NET, since other platforms may sort UUIDs differently.
	/// For <em>universally</em> sortable values, call <see cref="Guid.ToString()"/> on the values.
	/// Alternatively, values can be represented numerically (.NET7+ only). Until at least the year 4000, they fit in a DECIMAL(38) or a pair of signed BIGINTs (with the sign bits unused).
	/// </para>
	/// </summary>
	public static class DistributedId128
	{
#if NET7_0_OR_GREATER
		/// <summary>
		/// <para>
		/// Returns a new ID value, encoded as a <see cref="UInt128"/>, consisting of exactly 38 digits until beyond the year 4000.
		/// </para>
		/// <para>
		/// Note that the numeric (.NET7+ only) and <see cref="Guid"/> creation methods return identical values, encoded in different formats.
		/// Both are incremental.
		/// The two can be freely transcoded to one another using the extension methods provided by <see cref="IdEncodingExtensions"/>.
		/// </para>
		/// <para>
		/// View the class summary or the README for an extensive description of the ID's properties.
		/// </para>
		/// <para>
		/// The ID generator can be controlled by constructing a new <see cref="DistributedId128GeneratorScope"/> in a using statement.
		/// </para>
		/// </summary>
		public static UInt128 CreateId()
		{
			var id = DistributedId128GeneratorScope.CurrentGenerator.CreateId();
			return id;
		}
#endif

		/// <summary>
		/// <para>
		/// Returns a new ID value, encoded as a version-7 UUID.
		/// </para>
		/// <para>
		/// Note that the numeric (.NET7+ only) and <see cref="Guid"/> creation methods return identical values, encoded in different formats.
		/// Both are incremental.
		/// The two can be freely transcoded to one another using the extension methods provided by <see cref="IdEncodingExtensions"/>.
		/// </para>
		/// <para>
		/// View the class summary or the README for an extensive description of the ID's properties.
		/// </para>
		/// <para>
		/// The ID generator can be controlled by constructing a new <see cref="DistributedId128GeneratorScope"/> in a using statement.
		/// </para>
		/// </summary>
		public static Guid CreateGuid()
		{
			var id = DistributedId128GeneratorScope.CurrentGenerator.CreateGuid();
			return id;
		}

#if NET7_0_OR_GREATER

		/// <summary>
		/// <para>
		/// Splits the given <see cref="DistributedId128"/> value into its upper and lower halves, returned in that order.
		/// The halves are positive <see cref="Int64"/> values.
		/// </para>
		/// <para>
		/// If a value other than one generated by the <see cref="DistributedId128Generator"/> is passed, this method may throw.
		/// It expects the top bit of each half to be unset, to permit the use of two <see cref="Int64"/> values.
		/// </para>
		/// </summary>
		/// <param name="id">An <see cref="DistributedId128"/> value.</param>
		/// <returns>A pair consisting of the most significant 8 bytes first and the least significant 8 bytes last.</returns>
		public static (long, long) Split(UInt128 id)
		{
			var upper = (long)(id >> 64);
			var lower = (long)id;

			if (upper < 0L || lower < 0L)
				throw new ArgumentException($"A value generated by the {nameof(DistributedId128Generator)} was expected. The top bit of each half must be unset.");

			return (upper, lower);
		}

		/// <summary>
		/// <para>
		/// Reconstitutes a <see cref="DistributedId128"/> value from its upper and lower halves.
		/// </para>
		/// <para>
		/// If the input values together do not represent a value that could be generated by the <see cref="DistributedId128Generator"/>, this method may throw.
		/// It expects the top bit of each half to be unset, i.e. each half being positive.
		/// </para>
		/// </summary>
		/// <param name="upper">The most significant 8 bytes.</param>
		/// <param name="lower">The least significant 8 bytes.</param>
		public static UInt128 Join(long upper, long lower)
		{
			if (upper < 0L || lower < 0L)
				throw new ArgumentException($"A value generated by the {nameof(DistributedId128Generator)} was expected. The top bit of each half must be unset.");

			var result = ((UInt128)upper) << 64;
			result |= (UInt128)lower;
			return result;
		}

#endif
	}
}
